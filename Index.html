<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

<style>
html, body {
  background-color: #121212 !important;
  color: #e6e6e6 !important;
  font-family: 'Segoe UI', Arial, sans-serif;
  margin: 0;
  padding: 0;
  overflow-x: hidden;
}
table {
  width: 100%;
  background: rgba(0, 0, 0, 0.6);
  color: #fff;
  border-collapse: collapse;
}
th, td {
  padding: 6px;
  border: 1px solid #333;
  text-align: center;
}
input, select, button {
  background: #1f1f1f;
  color: #fff;
  border: 1px solid #333;
  padding: 6px;
  margin: 4px;
  border-radius: 4px;
}
button {
  background-color: #28a745;
}
#main-title {
  text-align: center;
  font-size: 2rem;
  font-weight: bold;
  margin: 20px 0 10px;
}
</style>

  <!-- Navigation Dropdown -->
  <div id="nav-dropdown">
    <select id="page-selector" onchange="changePage()">
      <option value="main-section">Main Page</option>
      <option value="howto-section">How To Use</option>
      <option value="trackrecord-section">Paper Trader Track Record</option>
      <option value="paperdata-section">Paper Data (Password)</option>
    </select>
  </div>
  
  <!-- Centered Title -->
  <div id="main-title" style="margin-top: 30px; padding-top: 5px;">Screener 5.2</div>
  
  <!-- Main Screener Section (Logs removed) -->
  <div id="main-section" style="display:block;" style="display:none;">
    <div class="container">
      <div class="controls">
        
      
<div id="fetch-status" style="text-align:center; font-size:0.9rem; color:#ccc; margin:5px;">
  <em>Status: <span id="status-text">Initializing...</span></em>
</div>

</div>
      <!-- Dropdown tables will be inserted here -->
      <div id="dropdown-container"></div>
      <!-- Price Chart -->
      <canvas id="price-chart"></canvas>
      <!-- Legal Disclaimer -->
      
    </div>
  </div>
  
  <!-- How To Use Section -->
  

<div id="main-section" style="display:block;" class="page-section" style="display: block;">
  <div class="controls">
    
  </div>
  <div id="dropdown-container"></div>
  <canvas id="price-chart"></canvas>
  
</div>

<div id="trackrecord-section" style="display:none;" class="page-section">
  
<div id="main-section" style="display:block;" class="page-section" style="display: block;">
  <div class="controls">
    
  </div>
  <div id="dropdown-container"></div>
  <canvas id="price-chart"></canvas>
  <details id="tos">
    <summary>Terms of Service & Liability Disclaimer</summary>
    <p>This tool is provided âas isâ without warranty of any kind. The creator disclaims all liability...</p>
  </details>
</div>

<div id="trackrecord-section" style="display:none;" class="page-section">
<h2>Paper Trader Track Record</h2>
  <table>
    <thead>
      <tr>
        <th>Coin</th>
        <th>Signal</th>
        <th>Entry Price</th>
        <th>Hold Time</th>
        <th>Time</th>
        <th>Exit Price</th>
        <th>P/L</th>
      </tr>
    </thead>
    <tbody id="trade-log-body"></tbody>
  </table>
</div>
</div>

<div id="howto-section" style="display:none;" class="page-section">
    <h2>How To Use</h2>
    <p>Welcome to Screener 5.2! Follow these steps to use the tool:</p>
    <ul>
      <li>Enter a coin name or symbol in the search box to filter results.</li>
      <li>Select your preferred currency from the dropdown and click "Refresh Data" to update information.</li>
      <li>Click on any trade signal to view detailed trade recommendations, charts, and probability metrics.</li>
      <li>Review all provided metrics and disclaimers before making any trading decisions.</li>
    </ul>
  </div>
  
  <!-- Paper Trader Track Record Section -->
  


<div id="main-section" style="display:block;" class="page-section" style="display: block;">
  <div class="controls">
    
  </div>
  <div id="dropdown-container"></div>
  <canvas id="price-chart"></canvas>
  <details id="tos">
    <summary>Terms of Service & Liability Disclaimer</summary>
    <p>This tool is provided âas isâ without warranty of any kind. The creator disclaims all liability...</p>
  </details>
</div>

<div id="trackrecord-section" style="display:none;" class="page-section">
  
  </div>
  
  <!-- Paper Data Section (Password Protected, with Logs) -->
  <div id="paperdata-section" style="display:none;" class="page-section">
    <div id="paperdata-section" style="display:none;" class="page-section">
<h2>Paper Data (Password Protected)</h2>
    <div id="paperdata-login">
      <p>Enter password:</p>
      <input type="password" id="paperdata-password">
      <button onclick="checkPaperDataPassword()">Submit</button>
</div>
    </div>
    <div id="paperdata-content" style="display:none;">
      <h3>Paper Data Logs</h3>
      <div id="paperdata-log" class="log">
        <!-- Logs are appended here via script -->
      </div>
    </div>
  </div>
  
  <!-- Modal for Trade Details and Chart -->
  <div id="signal-modal" class="modal">
    <div class="modal-content">
      <span class="close" id="modal-close">&times;</span>
      <div id="modal-body">
        <!-- Trade details will be injected here -->
      </div>
      <h3 style="text-align:center; color:#fff;">Chart</h3>
      <div id="indicator-chart-container">
        <canvas id="indicator-chart"></canvas>
      </div>
    </div>
  </div>
  
  <script>
    let cryptoData = [];
    let filteredData = [];
    let priceChart, indicatorChart;
    const defaultHoldDays = 1; // For profitability calculation

    // Append log messages to the #paperdata-log container
    function appendLog(message) {
      console.log(message);
      const logEl = document.getElementById('paperdata-log');
      if (logEl) {
        logEl.innerHTML += `<p>${message}</p>`;
        logEl.scrollTop = logEl.scrollHeight;
      }
    }
    
    // Determine if a coin is suspicious (example: MANTRA (OM))
    function isSuspiciousCoin(coin) {
      if (coin.name && coin.symbol) {
        return coin.name.toLowerCase().includes('mantra') && coin.symbol.toUpperCase() === 'OM';
      }
      return false;
    }
    
    // Dummy probability calculation based on volatility factor
    function computeProbabilityTrade(coin) {
      let base = 70;
      let adjustment = coin.volatilityFactor ? coin.volatilityFactor * 5 : 0;
      let probability = base - adjustment;
      if (probability < 10) probability = 10;
      if (probability > 90) probability = 90;
      return probability.toFixed(2) + "%";
    }
    
    async function fetchPaprikaData() {
      try {
        const response = await fetchWithRetry("https://api.coinpaprika.com/v1/tickers");
        return await response.json();
      } catch (error) {
        appendLog("Error fetching CoinPaprika data: " + error.message);
        return [];
      }
    }
    
    function mergeData(geckoData, paprikaData) {
      return geckoData.map(coin => {
        const match = paprikaData.find(p => p.symbol.toLowerCase() === coin.symbol.toLowerCase());
        if (match) {
          coin.market_cap = coin.market_cap || (match.quotes && match.quotes.USD && match.quotes.USD.market_cap);
          coin.total_volume = coin.total_volume || (match.quotes && match.quotes.USD && match.quotes.USD.volume_24h);
          coin.current_price = coin.current_price || (match.quotes && match.quotes.USD && match.quotes.USD.price);
          coin.price_change_percentage_24h = coin.price_change_percentage_24h || (match.quotes && match.quotes.USD && match.quotes.USD.percent_change_24h);
        }
        return coin;
      });
    }
    
    function computeProfitability(coin, holdDays) {
      let change = coin.price_change_percentage_24h;
      if (change >= 0) return 0;
      let volFactor = coin.total_volume / coin.market_cap;
      if (volFactor > 3) volFactor = 3;
      coin.volatilityFactor = volFactor;
      coin.derivativeSignal = volFactor >= 2.5;
      return (-change) * holdDays * volFactor;
    }
    
    function generateBuySignal(coin) {
      const pp = coin.profitPotential;
      if (pp < 5) return "Hold";
      if (pp < 8) return "Weak Buy";
      else if (pp < 12) return "Moderate Buy";
      else if (pp < 20) return "Buy";
      else if (pp < 30) return "Strong Buy";
      else return "Ultra Strong Buy";
    }
    
    async function fetchData() {
      const currency = document.getElementById('currency-select').value;
      appendLog("Fetching market data from CoinGecko...");
      try {
        const geckoUrls = [
          `https://api.coingecko.com/api/v3/coins/markets?vs_currency=${currency}&order=market_cap_desc&per_page=250&page=1`,
          `https://api.coingecko.com/api/v3/coins/markets?vs_currency=${currency}&order=market_cap_desc&per_page=250&page=2`,
          `https://api.coingecko.com/api/v3/coins/markets?vs_currency=${currency}&order=market_cap_desc&per_page=250&page=3`,
          `https://api.coingecko.com/api/v3/coins/markets?vs_currency=${currency}&order=market_cap_desc&per_page=250&page=4`
        ];
        const geckoResponses = await Promise.all(geckoUrls.map(url => fetchWithRetry(url)));
        const geckoData = geckoResponses.flat();
        appendLog("CoinGecko data fetched. Data count: " + geckoData.length);
        appendLog("Fetching additional data from CoinPaprika...");
        const paprikaData = await fetchPaprikaData();
        appendLog("CoinPaprika data fetched.");
        cryptoData = mergeData(geckoData, paprikaData);
        cryptoData = cryptoData.filter(coin => !isSuspiciousCoin(coin));
        cryptoData.forEach(coin => {
          coin.profitPotential = computeProfitability(coin, defaultHoldDays);
          coin.tradingSignal = coin.derivativeSignal ? "Derivative Trade" : generateBuySignal(coin);
        });
        filteredData = cryptoData;
        appendLog("Data merged and signals computed. Total coins: " + filteredData.length);
        populateDropdownTables();
        if (filteredData.length > 0) renderChart(filteredData[0]);
      } catch (error) {
        appendLog("Error fetching market data: " + error.message);
      }
    }
    
    function populateDropdownTables() {
      const container = document.getElementById('dropdown-container');
      container.innerHTML = "";
      const buyCategories = ["Weak Buy", "Moderate Buy", "Buy", "Strong Buy", "Ultra Strong Buy"];
      buyCategories.forEach(category => {
        const group = filteredData.filter(coin => !coin.derivativeSignal && coin.tradingSignal === category);
        if (!group.length) return;
        group.sort((a, b) => b.profitPotential - a.profitPotential);
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = `${category} - Showing ${group.length} coins (sorted by profitability)`;
        details.appendChild(summary);
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr>
            <th>Rank</th>
            <th>Symbol</th>
            <th>Name</th>
            <th>Price</th>
            <th>Market Cap</th>
            <th>Volume</th>
            <th>24h Change</th>
            <th>Profit Potential (%)</th>
            <th>Trade Signal</th>
          </tr>
        `;
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        group.forEach(coin => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${coin.market_cap_rank || "N/A"}</td>
            <td>${coin.symbol.toUpperCase()}</td>
            <td>${coin.name}</td>
            <td>$${coin.current_price ? coin.current_price.toLocaleString() : "N/A"}</td>
            <td>$${coin.market_cap ? coin.market_cap.toLocaleString() : "N/A"}</td>
            <td>$${coin.total_volume ? coin.total_volume.toLocaleString() : "N/A"}</td>
            <td>${coin.price_change_percentage_24h ? coin.price_change_percentage_24h.toFixed(2) + "%" : "N/A"}</td>
            <td>${coin.profitPotential.toFixed(2)}</td>
            <td><span class="buy-signal" onclick="handleCoinClick('${coin.id}')">${coin.tradingSignal}</span></td>
          `;
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        details.appendChild(table);
        container.appendChild(details);
      });
      
      const derivatives = filteredData.filter(coin => coin.derivativeSignal);
      if (derivatives.length) {
        derivatives.sort((a, b) => b.profitPotential - a.profitPotential);
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = `Derivative Trades - Showing ${derivatives.length} coins (sorted by profitability)`;
        details.appendChild(summary);
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr>
            <th>Rank</th>
            <th>Symbol</th>
            <th>Name</th>
            <th>Price</th>
            <th>Market Cap</th>
            <th>Volume</th>
            <th>24h Change</th>
            <th>Profit Potential (%)</th>
            <th>Trade Signal</th>
          </tr>
        `;
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        derivatives.forEach(coin => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${coin.market_cap_rank || "N/A"}</td>
            <td>${coin.symbol.toUpperCase()}</td>
            <td>${coin.name}</td>
            <td>$${coin.current_price ? coin.current_price.toLocaleString() : "N/A"}</td>
            <td>$${coin.market_cap ? coin.market_cap.toLocaleString() : "N/A"}</td>
            <td>$${coin.total_volume ? coin.total_volume.toLocaleString() : "N/A"}</td>
            <td>${coin.price_change_percentage_24h ? coin.price_change_percentage_24h.toFixed(2) + "%" : "N/A"}</td>
            <td>${coin.profitPotential.toFixed(2)}</td>
            <td><span class="buy-signal" onclick="handleCoinClick('${coin.id}')">${coin.tradingSignal}</span></td>
          `;
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        details.appendChild(table);
        container.appendChild(details);
      }
    }
    
    function handleCoinClick(coinId) {
      const coin = cryptoData.find(c => c.id === coinId);
      if (!coin) return;
      showSignalDetails(coin, defaultHoldDays);
      renderIndicatorChart(coin);
    }
    
    function showSignalDetails(coin, holdDays) {
      const modal = document.getElementById('signal-modal');
      const modalBody = document.getElementById('modal-body');
      modalBody.innerHTML = `
        <h2>${coin.name} (${coin.symbol.toUpperCase()})</h2>
        <p><strong>Current Price:</strong> $${coin.current_price ? coin.current_price.toLocaleString() : "N/A"}</p>
        <p><strong>Market Cap:</strong> $${coin.market_cap ? coin.market_cap.toLocaleString() : "N/A"}</p>
        <p><strong>24h Change:</strong> ${coin.price_change_percentage_24h ? coin.price_change_percentage_24h.toFixed(2) + "%" : "N/A"}</p>
        <p><strong>Advanced Profitability (Hold ${holdDays} Day${holdDays>1?'s':''}):</strong> ${computeProfitability(coin, holdDays).toFixed(2)}%</p>
        <p><strong>Trade to Make:</strong></p>
        <ul>
          <li>Buy at current price: $${coin.current_price ? coin.current_price.toLocaleString() : "N/A"}</li>
          <li>Set stop-loss at ~10% below current price.</li>
          <li>Target an upside of approximately ${computeProfitability(coin, holdDays).toFixed(2)}% within ${holdDays} day${holdDays>1?'s':''}.</li>
          <li>Probability of trade occurring: ${computeProbabilityTrade(coin)}</li>
          <li>Monitor the market and adjust your position as needed.</li>
        </ul>
        <p><strong>Recommended Trade Strategy:</strong> ${coin.tradingSignal}</p>
        <p><strong>Reasoning:</strong> This coin exhibits a significant decline with a favorable volume-to-market-cap ratio. Our advanced heuristics, including probability metrics, refine the trade signal.</p>
        <p style="font-size:0.7rem; color:#aaa;">
          *This recommendation is provided as-is without any warranty. Use at your own risk.
        </p>
      `;
      modal.style.display = "block";
    }
    
    async function renderChart(coin) {
      const currency = document.getElementById('currency-select').value;
      appendLog(`Fetching 30-day historical data for ${coin.id} (Price Chart)...`);
      try {
        const url = `https://api.coingecko.com/api/v3/coins/${coin.id}/market_chart?vs_currency=${currency}&days=30`;
        const response = await fetch(url);
        if (!response.ok) throw new Error("Historical price chart fetch failed");
        const data = await response.json();
        let historicalData = data.prices.map(item => ({
          date: new Date(item[0]).toLocaleDateString(),
          price: item[1]
        }));
        const step = Math.ceil(historicalData.length / 30);
        historicalData = historicalData.filter((_, idx) => idx % step === 0);
        appendLog(`Price Chart: ${historicalData.length} data points after sampling.`);
        if (!historicalData.length) throw new Error("No historical data available");
        if (priceChart) priceChart.destroy();
        const ctx = document.getElementById('price-chart').getContext('2d');
        priceChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: historicalData.map(d => d.date),
            datasets: [{
              label: `${coin.name} Price (${currency.toUpperCase()})`,
              data: historicalData.map(d => d.price),
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              fill: true,
              tension: 0.2
            }]
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: false,
                ticks: { callback: value => '$' + value.toLocaleString(), color: '#fff' },
                grid: { color: 'rgba(200,200,200,0.1)' }
              },
              x: { ticks: { color: '#fff' }, grid: { color: 'rgba(200,200,200,0.1)' } }
            }
          }
        });
        appendLog("Price chart rendered successfully.");
      } catch (error) {
        appendLog("Error rendering price chart: " + error.message);
      }
    }
    
    async function renderIndicatorChart(coin) {
      const currency = document.getElementById('currency-select').value;
      appendLog(`Fetching 30-day historical data for ${coin.id} (Regular Chart)...`);
      try {
        const url = `https://api.coingecko.com/api/v3/coins/${coin.id}/market_chart?vs_currency=${currency}&days=30`;
        appendLog("Regular Chart URL: " + url);
        const response = await fetch(url);
        if (!response.ok) throw new Error("Regular chart fetch failed");
        const data = await response.json();
        let historicalData = data.prices.map(item => ({
          date: new Date(item[0]).toLocaleDateString(),
          price: item[1]
        }));
        const step = Math.ceil(historicalData.length / 30);
        historicalData = historicalData.filter((_, idx) => idx % step === 0);
        appendLog(`Regular Chart: ${historicalData.length} data points after sampling.`);
        if (!historicalData.length) throw new Error("No historical data available");
        const labels = historicalData.map(d => d.date);
        const prices = historicalData.map(d => d.price);
        if (indicatorChart) indicatorChart.destroy();
        const ctx = document.getElementById('indicator-chart').getContext('2d');
        indicatorChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: `${coin.name} Price (${currency.toUpperCase()})`,
              data: prices,
              borderColor: 'rgba(255, 99, 132, 1)',
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              fill: false,
              tension: 0.2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: false,
                ticks: { callback: value => '$' + value.toLocaleString(), color: '#fff' },
                grid: { color: 'rgba(200,200,200,0.1)' }
              },
              x: { ticks: { color: '#fff' }, grid: { color: 'rgba(200,200,200,0.1)' } }
            }
          }
        });
        appendLog("Regular (indicator) chart rendered successfully.");
      } catch (error) {
        appendLog("Error rendering regular chart: " + error.message);
      }
    }
    
    function filterTable() {
      const term = document.getElementById('search-input').value.toLowerCase();
      filteredData = cryptoData.filter(coin =>
        coin.name.toLowerCase().includes(term) || coin.symbol.toLowerCase().includes(term)
      );
      filteredData.forEach(coin => {
        coin.profitPotential = computeProfitability(coin, defaultHoldDays);
        coin.tradingSignal = coin.derivativeSignal ? "Derivative Trade" : generateBuySignal(coin);
      });
      populateDropdownTables();
    }
    
    document.getElementById('modal-close').addEventListener('click', () => {
      document.getElementById('signal-modal').style.display = "none";
    });
    
    window.onclick = function(event) {
      const modal = document.getElementById('signal-modal');
      if (event.target == modal) modal.style.display = "none";
    };
    
    function changePage() {
      const page = document.getElementById('page-selector').value;
      document.getElementById('main-section').style.display = "none";
      document.getElementById('howto-section').style.display = "none";
      document.getElementById('trackrecord-section').style.display = "none";
      document.getElementById('paperdata-section').style.display = "none";
      
      if (page === "main-section") {
        document.getElementById('main-section').style.display = "block";
      } else if (page === "howto-section") {
        document.getElementById('howto-section').style.display = "block";
      } else if (page === "trackrecord-section") {
        document.getElementById('trackrecord-section').style.display = "block";
      } else if (page === "paperdata-section") {
        document.getElementById('paperdata-section').style.display = "block";
      }
    }
    
    function checkPaperDataPassword() {
      const password = document.getElementById('paperdata-password').value;
      if (password === "122216") {
        document.getElementById('paperdata-login').style.display = "none";
        document.getElementById('paperdata-content').style.display = "block";
      } else {
        alert("Incorrect password. Please try again.");
      }
    }
    
    
document.addEventListener("DOMContentLoaded", function() {
  setTimeout(() => {
    document.getElementById("main-section").style.display = "block";
    fetchData();
  }, 2000);
};

  </script>
  <!-- Legal Disclaimer at Bottom -->
  <div id="legal">
    By using this tool, you agree that it is provided "as is" without any gaurantees. You must do your own research, these are reccomendations. The creator assumes no liability for any damages. Perform your own due diligence before trading.
  </div>


<script>
  let paperTrades = [];

  function simulatePaperTrade(coin, signal, price, holdTime) {
    const now = new Date();
    const trade = {
      coin: coin.name || coin.symbol || "N/A",
      signal: signal,
      entryPrice: price,
      holdTime: holdTime,
      time: now.toLocaleString(),
      exitPrice: null,
      profitLoss: null
    };
    paperTrades.push(trade);
    updateTradeLog();
    updateProfitChart();
  }

  function updateTradeLog() {
    const table = document.getElementById("trade-log-body");
    if (!table) return;
    table.innerHTML = "";
    paperTrades.forEach(trade => {
      const row = document.createElement("tr");
      row.innerHTML = `
        <td>${trade.coin}</td>
        <td>${trade.signal}</td>
        <td>$${trade.entryPrice}</td>
        <td>${trade.holdTime}h</td>
        <td>${trade.time}</td>
        <td>${trade.exitPrice ? "$" + trade.exitPrice : "â"}</td>
        <td>${trade.profitLoss !== null ? (trade.profitLoss >= 0 ? "+" : "") + trade.profitLoss.toFixed(4) : "â"}</td>
      `;
      table.appendChild(row);
    });
  }

  function updateProfitChart() {
    const ctx = document.getElementById('profitChart')?.getContext('2d');
    if (!ctx) return;
    const profits = paperTrades.filter(t => t.profitLoss !== null).map(t => t.profitLoss);
    const cumulative = profits.reduce((acc, val, i) => {
      acc.push((acc[i - 1] || 0) + val);
      return acc;
    }, []);
    if (window.profitChartInstance) window.profitChartInstance.destroy();
    window.profitChartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels: cumulative.map((_, i) => i + 1),
        datasets: [{
          label: 'Portfolio P/L',
          data: cumulative,
          borderWidth: 2,
          fill: false
        }]
      },
      options: {
        responsive: true,
        scales: {
          y: { beginAtZero: true }
        }
      }
    });
  }

  function  {
    let csv = 'Coin,Signal,Entry Price,Hold Time,Time,Exit Price,P/L\n';
    paperTrades.forEach(trade => {
      csv += `${trade.coin},${trade.signal},${trade.entryPrice},${trade.holdTime},${trade.time},${trade.exitPrice || ""},${trade.profitLoss || ""}\n`;
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'paper_trades.csv';
    link.click();
  }

  setInterval(() => {
    const now = new Date();
    paperTrades.forEach(trade => {
      if (trade.exitPrice === null) {
        const enteredAt = new Date(trade.time);
        const holdDurationMs = parseFloat(trade.holdTime) * 60 * 60 * 1000;
        if (now - enteredAt >= holdDurationMs) {
          const exitPrice = trade.entryPrice * (Math.random() * 0.1 + 0.95);
          trade.exitPrice = parseFloat(exitPrice.toFixed(6));
          trade.profitLoss = parseFloat((trade.exitPrice - trade.entryPrice).toFixed(6));
        }
      }
    });
    updateTradeLog();
    updateProfitChart();
  }, 60000);

  function runAutoPaperTrader() {
    if (!window.filteredData || filteredData.length === 0) return;
    const validSignals = ["Buy", "Strong Buy", "Ultra Strong Buy", "Moderate Buy", "Weak Buy", "Derivative Trade"];
    filteredData.forEach(coin => {
      if (validSignals.includes(coin.tradingSignal)) {
        simulatePaperTrade(coin, coin.tradingSignal, coin.current_price, 2);
      }
    });
  }
</script>


<script>
function logDebug(message) {
  const out = document.getElementById('debug-output');
  if (out) {
    const time = new Date().toLocaleTimeString();
    out.innerHTML += `[${time}] ${message}\n`;
    out.scrollTop = out.scrollHeight;
  }
}
logDebug("Debug log initialized...");
if (!window.filteredData) {
  logDebug("filteredData is not defined.");
} else {
  logDebug("filteredData exists. Length: " + filteredData.length);
}
</script>


<script>
function smoothLoadCheck() {
  logDebug("Checking DOM readiness and filteredData...");
  if (!window.filteredData || !Array.isArray(filteredData) || filteredData.length === 0) {
    logDebug("filteredData is empty or not yet loaded. Retrying...");
    setTimeout(smoothLoadCheck, 1000);
  } else {
    logDebug("filteredData loaded with " + filteredData.length + " coins.");
    setTimeout(() => { runAutoPaperTrader(); }, 2000);
  }
}

document.addEventListener("DOMContentLoaded", function() {
  setTimeout(() => {
    document.getElementById("main-section").style.display = "block";
    fetchData();
  }, 2000);
};

</script>


<script>
async function renderIndicatorChartFromTrade(coinId) {
  const currency = document.getElementById('currency-select')?.value || 'usd';
  try {
    const url = `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=${currency}&days=30`;
    const response = await fetch(url);
    const data = await response.json();
    const historicalData = data.prices.map(p => ({
      date: new Date(p[0]).toLocaleDateString(),
      price: p[1]
    }));

    const ctx = document.getElementById('indicator-chart')?.getContext('2d');
    if (!ctx) return;
    if (window.indicatorChart) window.indicatorChart.destroy();

    window.indicatorChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: historicalData.map(d => d.date),
        datasets: [{
          label: `${coinId.toUpperCase()} Price`,
          data: historicalData.map(d => d.price),
          borderColor: 'rgba(54, 162, 235, 1)',
          backgroundColor: 'rgba(54, 162, 235, 0.2)',
          fill: true,
          tension: 0.2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: false,
            ticks: { color: '#fff' },
            grid: { color: 'rgba(200,200,200,0.1)' }
          },
          x: {
            ticks: { color: '#fff' },
            grid: { color: 'rgba(200,200,200,0.1)' }
          }
        }
      }
    });
  } catch (error) {
    console.error("Chart rendering failed:", error);
  }
}
</script>


<script>

function setStatus(text) {
  const el = document.getElementById("status-text");
  if (el) {
    el.innerText = text;
    const existingSpinner = document.getElementById("status-spinner");
    if (text.includes("Fetching") || text.includes("Loading")) {
      if (!existingSpinner) {
        const spinner = document.createElement("span");
        spinner.className = "spinner";
        spinner.id = "status-spinner";
        el.parentElement.appendChild(spinner);
      }
    } else if (existingSpinner) {
      existingSpinner.remove();
    }
  }
}

  const el = document.getElementById("status-text");
  if (el) el.innerText = text;
}
setStatus("Loading live data...");

async function fetchData() {
  const currency = document.getElementById('currency-select').value;
  setStatus("Fetching market data...");
  try {
    const geckoUrls = [
      `https://api.coingecko.com/api/v3/coins/markets?vs_currency=${currency}&order=market_cap_desc&per_page=250&page=1`,
      `https://api.coingecko.com/api/v3/coins/markets?vs_currency=${currency}&order=market_cap_desc&per_page=250&page=2`
    ];
    const geckoResponses = await Promise.all(geckoUrls.map(url => fetchWithRetry(url)));
    const geckoData = geckoResponses.flat();
    setStatus("Fetching additional CoinPaprika data...");

    const response = await fetchWithRetry("https://api.coinpaprika.com/v1/tickers");
    const paprikaData = await response.json();
    setStatus("Merging datasets...");

    cryptoData = mergeData(geckoData, paprikaData);
    cryptoData = cryptoData.filter(coin => !isSuspiciousCoin(coin));
    cryptoData.forEach(coin => {
      coin.profitPotential = computeProfitability(coin, defaultHoldDays);
      coin.tradingSignal = coin.derivativeSignal ? "Derivative Trade" : generateBuySignal(coin);
    });

    filteredData = cryptoData;
    setStatus(`Loaded ${filteredData.length} coins successfully.`);
    populateDropdownTables();
    if (filteredData.length > 0) renderChart(filteredData[0]);
    setTimeout(() => runAutoPaperTrader(), 1500);
  } catch (error) {
    console.error("Fetch Error:", error.message);
    setStatus("Failed to fetch live data. Please try again.");
  }
}
</script>


<script>
// Profitability Optimizer v1.0 - Filters & Dynamic Trading Logic

function meetsOptimizerCriteria(coin) {
  if (!coin || !coin.current_price || !coin.market_cap || !coin.total_volume || !coin.price_change_percentage_24h) return false;

  const rsi = coin.rsi || 45; // fallback value
  const macd = coin.macd || 0; // placeholder if missing
  const volumeSpike = (coin.total_volume / coin.market_cap) > 0.10;
  const bullishRSI = rsi > 35 && rsi < 70;
  const bullishMACD = macd > 0;

  return bullishRSI && bullishMACD && volumeSpike;
}

function getConfidenceScore(coin) {
  let score = 0;
  if ((coin.total_volume / coin.market_cap) > 0.10) score += 1;
  if (coin.macd > 0) score += 1;
  if (coin.rsi >= 40 && coin.rsi <= 70) score += 1;
  if (coin.profitPotential > 10) score += 1;
  return score;
}

function runAutoPaperTrader() {
  const table = document.getElementById("trade-log-body");
  if (!table || !filteredData || !filteredData.length) return;

  const now = new Date().toLocaleTimeString();
  filteredData.forEach(coin => {
    const signal = coin.tradingSignal;
    const isValid = ["Buy", "Strong Buy", "Ultra Strong Buy", "Derivative Trade"].includes(signal);
    const meetsCriteria = meetsOptimizerCriteria(coin);
    if (!isValid || !meetsCriteria) return;

    const confidence = getConfidenceScore(coin);
    const entryPrice = coin.current_price;
    const holdTime = confidence >= 3 ? 12 : confidence >= 2 ? 6 : 2;
    const targetGain = confidence * 2;
    const exitPrice = +(entryPrice * (1 + (targetGain / 100))).toFixed(4);

    paperTrades.push({
      coin: coin.symbol.toUpperCase(),
      signal,
      entryPrice,
      holdTime,
      time: now,
      exitPrice: null,
      profitLoss: null,
      confidence
    });
  });

  updateTradeLog();
}
</script>


<style>
#floating-summary {
  position: fixed;
  bottom: 15px;
  right: 10px;
  background: #111;
  border: 1px solid #555;
  border-radius: 8px;
  padding: 10px;
  color: #eee;
  font-size: 0.8rem;
  z-index: 1000;
  box-shadow: 0 0 6px #000;
}
</style>
<div id="floating-summary">
  <div><strong>Active Trades:</strong> <span id="summary-count">0</span></div>
  <div><strong>Win %:</strong> <span id="summary-win">0%</span></div>
  <div><strong>Avg P/L:</strong> <span id="summary-avg">0%</span></div>
</div>


<script>
function updateFloatingSummary() {
  const wins = paperTrades.filter(t => t.profitLoss > 0).length;
  const total = paperTrades.length;
  const avg = paperTrades.filter(t => t.profitLoss !== null).reduce((acc, t) => acc + t.profitLoss, 0) / (total || 1);

  document.getElementById("summary-count").innerText = total;
  document.getElementById("summary-win").innerText = total ? ((wins / total) * 100).toFixed(1) + "%" : "0%";
  document.getElementById("summary-avg").innerText = avg.toFixed(2) + "%";
}

// Hook into existing interval
setInterval(updateFloatingSummary, 3000);
</script>


<script>
document.getElementById("modal-close").onclick = () => {
  document.getElementById("signal-modal").style.display = "none";
};
window.onclick = function(event) {
  const modal = document.getElementById("signal-modal");
  if (event.target === modal) modal.style.display = "none";
};

function handleCoinClick(coinId) {
  const coin = (window.filteredData || []).find(c => c.id === coinId);
  if (!coin) return;
  showSignalDetails(coin, 1);
  renderIndicatorChart(coin);
  document.getElementById("signal-modal").style.display = "block";
}

async function renderIndicatorChart(coin) {
  const currency = document.getElementById('currency-select')?.value || 'usd';
  try {
    const url = `https://api.coingecko.com/api/v3/coins/${coin.id}/market_chart?vs_currency=${currency}&days=30`;
    const res = await fetch(url);
    const data = await res.json();
    const points = data.prices.map(d => ({
      date: new Date(d[0]).toLocaleDateString(),
      price: d[1]
    }));
    const ctx = document.getElementById("indicator-chart").getContext("2d");
    if (window.indicatorChart) window.indicatorChart.destroy();
    window.indicatorChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: points.map(p => p.date),
        datasets: [{
          label: `${coin.name} Price`,
          data: points.map(p => p.price),
          borderColor: '#00ccff',
          backgroundColor: 'rgba(0,204,255,0.2)',
          fill: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            ticks: { color: '#fff' },
            grid: { color: 'rgba(200,200,200,0.1)' }
          },
          x: {
            ticks: { color: '#fff' },
            grid: { color: 'rgba(200,200,200,0.1)' }
          }
        }
      }
    });
  } catch (e) {
    console.error("Chart error", e);
  }
}

function showSignalDetails(coin, holdDays) {
  const el = document.getElementById("modal-body");
  el.innerHTML = `
    <h3>${coin.name} (${coin.symbol.toUpperCase()})</h3>
    <p><b>Current Price:</b> $${coin.current_price.toFixed(4)}</p>
    <p><b>Market Cap:</b> $${(coin.market_cap || 0).toLocaleString()}</p>
    <p><b>24h Change:</b> ${coin.price_change_percentage_24h?.toFixed(2)}%</p>
    <p><b>Trade Signal:</b> ${coin.tradingSignal}</p>
    <p><b>Projected Gain:</b> ${coin.profitPotential.toFixed(2)}%</p>
    <p><b>Confidence Score:</b> ${getConfidenceScore(coin)}</p>
    <p><b>Strategy:</b> Buy and hold ${holdDays}h unless target hit earlier.</p>
  `;
}
</script>

</body>
</html>
